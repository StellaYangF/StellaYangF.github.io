import{_ as s,o as a,c as l,U as n}from"./chunks/framework.e95afc2d.js";const h=JSON.parse('{"title":"性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"front/performance/index.md","filePath":"front/performance/index.md"}'),e={name:"front/performance/index.md"},p=n(`<h1 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h1><p>“从地址栏输入XXX到访问之间经历了什么？” 这一过程经历的阶段，均有优化的机会：</p><ul><li>查询缓存</li><li>发送请求</li><li>等待响应</li><li>页面解析</li><li>下载并处理各类静态资源</li><li>运行时</li><li>预加载</li></ul><p>参考：</p><ul><li><a href="https://alienzhou.github.io/fe-performance-journey/" target="_blank" rel="noreferrer">前端性能优化</a></li><li><a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/" target="_blank" rel="noreferrer">A Tale of Four Caches</a></li></ul><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><h3 id="本地数据存储" tabindex="-1">本地数据存储 <a class="header-anchor" href="#本地数据存储" aria-label="Permalink to &quot;本地数据存储&quot;">​</a></h3><p>直接在业务代码侧进行缓存处理。缓存方式包括 <code>localStorage</code>, <code>sessionStorage</code>, <a href="https://medium.com/free-code-camp/a-quick-but-complete-guide-to-indexeddb-25f030425501" target="_blank" rel="noreferrer">indexedDB</a></p><p>例如，我们的页面上有一个日更新的榜单，我们可以做一个当日缓存：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 当用户加载站点中的榜单组件时，可以通过该方法获取榜单数据</span></span>
<span class="line"><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">readListData</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">info</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parse</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getItem</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">listInfo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">isExpired</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">info</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">time</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Date</span><span style="color:#F07178;">))) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fetchList</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setItem</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">listInfo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            time</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Date</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">            list</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">info</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">list</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>对于一些特殊的、轻量级的业务数据，可以考虑使用本地存储作为缓存。</p><p><code>Local/session</code> 存储体积小(且不一致)</p><ul><li>浏览器实现可为每个站点提供 2MB - 10MB 控件</li></ul><p><code>indexDB</code> 是一种异步缓存 API，不会阻塞 UI 线程。</p><ul><li>key/value 存储</li><li>数据存储不受限</li><li>支持所有现代浏览器</li><li>支持事务、版本控制，提供良好性能</li><li>跨域无法访问</li></ul><p><code>Web SQL</code> 已废弃</p><h3 id="内存缓存-memory" tabindex="-1">内存缓存 Memory <a class="header-anchor" href="#内存缓存-memory" aria-label="Permalink to &quot;内存缓存 Memory&quot;">​</a></h3><p>webpack 进行懒加载时，使用 JSONP 形式引入，且使用 <a href="https://calendar.perfplanet.com/2013/big-bad-preloader/" target="_blank" rel="noreferrer">preloader</a>，预抓取出其他子页面可能会用到内容，存储在 memory cache 中</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">preload</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxx.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">as</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">javascript</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;"> /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>不关心 HTTP语义 如：<code>max-age=0</code> 或者 <code>no-cache</code> <code>Cache-Control</code></li></ul><p>补充：</p><ul><li>no-cache：是把资源进行了本地缓存，在浏览器使用缓存之前，会使用 <code>last-Modified</code> 和 <code>Etag</code> 往返浏览器进行对比，判断时间和唯一标识符和服务器的是否一致，一致的话304使用缓存，不一致的话请求服务器。</li><li>no-store: 禁用本地缓存</li></ul><h3 id="cache-api" tabindex="-1">Cache API <a class="header-anchor" href="#cache-api" aria-label="Permalink to &quot;Cache API&quot;">​</a></h3><p>提供给了客户端构建请求缓存机制的能力。</p><p>PWA (Progressive Web App) 或者 Service Worker</p><p>Service Worker 是一个后台运行的独立线程，可以在代码中启用</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// index.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">serviceWorker</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> navigator) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">navigator</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">serviceWorker</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">register</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./sw.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 注册成功</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>之后需要处理一些 Service Worker 的生命周期事件，而其中与这里提到的缓存功能直接相关的则是请求拦截：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// sw.js</span></span>
<span class="line"><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">fetch</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 如果有cache则直接返回，否则通过fetch请求</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">respondWith</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">caches</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">request</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">cache</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">cache</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fetch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">request</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">catch</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">err</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fetch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">request</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>以上代码会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。与内存缓存不同，Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。</p><p><a href="https://juejin.im/post/5aca14b6f265da237c692e6f" target="_blank" rel="noreferrer">PWA 学习与实践</a></p><p>测试浏览器兼容性： <a href="https://caniuse.com/#search=service%20worker" target="_blank" rel="noreferrer">caniuse</a></p><h3 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h3><p>缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</p><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><p><strong>Expires(HTTP1.0)</strong>：Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p><p><strong>缺点</strong>：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。</p><p><strong>Pragma(HTTP1.0)</strong>：HTTP1.0时的遗留字段，当值为&quot;no-cache&quot;时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加&#39;Pragma&#39;: &#39;no-cache&#39;，浏览器表现行为和刷新(F5)类似。</p><p><strong>Cache-Control(HTTP1.1)</strong>：有很多属性，不同的属性代表的意义也不同：</p><ul><li>private：客户端可以缓存</li><li>public：客户端和代理服务器都可以缓存</li><li>max-age=t：缓存内容将在t秒后失效</li><li>no-cache：需要使用协商缓存来验证缓存数据</li><li>no-store：所有内容都不会缓存</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><p>强缓存不是那么灵活。如果我在 300 秒内更新了资源，需要怎么通知客户端呢？常用的方式就是通过协商缓存。</p><p>远程请求慢的一大原因就是报文体积较大。协商缓存就是希望能通过先“问一问”服务器资源到底有没有过期，来避免无谓的资源下载。这伴随的往往会是 HTTP 请求中的 304 响应码。</p><p>一种协防缓存的方式是：服务器第一次响应时返回 Last-Modified，而浏览器在后续请求时带上其值作为 If-Modified-Since，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p><p>上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— ETag。服务器第一次响应时返回 ETag，而浏览器在后续请求时带上其值作为 If-None-Match。一般会用文件的 MD5 作为 ETag。</p><h3 id="push-cache" tabindex="-1">Push Cache <a class="header-anchor" href="#push-cache" aria-label="Permalink to &quot;Push Cache&quot;">​</a></h3><p>假如很不幸，以上这些缓存你都没有命中，那么你将会碰到最后一个缓存检查 —— Push Cache。</p><p>push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源。例如，你在请求 www.sample.com 时，服务端不仅发送了页面文档，还一起推送了 关键 CSS 样式表。这也就避免了浏览器收到响应、解析到相应位置时才会请求所带来的延后。</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Page: Hey example.com, can I have your homepage please? 10:24</span></span>
<span class="line"><span style="color:#A6ACCD;">Server: Sure thing! Oh, but while I&#39;m sending you that, here&#39;s a stylesheet, some images, some JavaScript, and some JSON. 10:24</span></span>
<span class="line"><span style="color:#A6ACCD;">Page: Uh, sure.10:24</span></span>
<span class="line"><span style="color:#A6ACCD;">Page: I&#39;m just reading the HTML here, and it looks like I&#39;m going to need a stylesh… oh it&#39;s the one you&#39;re already sending me, cool!10:25</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>参考: <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noreferrer">HTTP/2 push is tougher than I thought</a></p><h2 id="发送请求" tabindex="-1">发送请求 <a class="header-anchor" href="#发送请求" aria-label="Permalink to &quot;发送请求&quot;">​</a></h2><ul><li><p>避免多余重定向</p><p>重定向分为 301 的永久重定向和 302 的临时重定向。</p><p>建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p></li><li><p>DNS 预解析</p><p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//yourwebsite.com&quot;&gt;</code></p></li><li><p>预先建立连接</p><p><code>&lt;link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; crossorigin&gt;</code></p></li><li><p>使用 CDN 静态资源，我们可以考虑通过 CDN 来降低时延。</p></li></ul><h2 id="服务端响应" tabindex="-1">服务端响应 <a class="header-anchor" href="#服务端响应" aria-label="Permalink to &quot;服务端响应&quot;">​</a></h2><ul><li>使用流进行响应</li><li>业务聚合 NodeJS</li><li>避免代码问题 <ul><li>async await 的不当使用导致并行请求被串行化了；</li><li>频繁地 JSON.parse 和 JSON.stringify 大对象；</li><li>正则表达式的灾难性回溯；</li><li>闭包导致的内存泄漏；</li><li>CPU 密集型任务导致事件循环 delay 严重；</li><li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；</li></ul></li></ul><h2 id="页面解析与处理" tabindex="-1">页面解析与处理 <a class="header-anchor" href="#页面解析与处理" aria-label="Permalink to &quot;页面解析与处理&quot;">​</a></h2><p>要注意的点：</p><ul><li><p>注意资源在页面文档中的位置</p><ul><li><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p></li><li><p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 ——</p></li><li><p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。</p></li></ul></li><li><p>使用 defer 和 async</p><ul><li>两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建</li><li>defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；</li><li>async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</li><li>推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 async 可以有效避免这些非核心功能的加载影响页面解析速度。</li></ul></li><li><p>页面文档压缩</p></li></ul><h2 id="页面静态资源" tabindex="-1">页面静态资源 <a class="header-anchor" href="#页面静态资源" aria-label="Permalink to &quot;页面静态资源&quot;">​</a></h2><h3 id="javascript" tabindex="-1">JavaScript <a class="header-anchor" href="#javascript" aria-label="Permalink to &quot;JavaScript&quot;">​</a></h3><ul><li>减少不必要的请求 <ul><li>代码拆分（code split）与按需加载 <ul><li>webpack or <a href="https://requirejs.org/" target="_blank" rel="noreferrer">RequireJS</a></li></ul></li><li>代码合并</li></ul></li><li>减少包体大小 <ul><li><p>代码压缩</p><ul><li>uglify, production 模式下默认开始，将变量替换为短命名、去掉多余的换行符等方式</li><li>文本压缩算法 gzip，Content-Encoding: gzip</li></ul></li><li><p>Tree Shaking</p><ul><li>optimization.usedExports: [] | boolean</li><li>package.json.sideEffects</li><li>通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 模块 A</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">minus</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 模块 B</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">add</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">module.A.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>上面的代码中使用了 ESM 规范的模块语法，而没有使用 CommonJS Tree Shaking 算是一种静态分析，而 ESM 本身是一种的静态的模块化规范，所有依赖可以在编译期确定</p></blockquote></li><li><p>优化 polyfill 的使用</p><ul><li>用于在非兼容浏览器上也能使用新特性的 API。后续升级不用改动业务代码，只需要删除相应的 polyfill 即可。</li><li><a href="https://github.com/browserslist/browserslist" target="_blank" rel="noreferrer">browserslist</a></li></ul></li><li><p>webpack</p><ul><li>webpack-bundle-analyzer 这个工具来查看打包代码里面各个模块的占用大小。</li><li><a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="noreferrer">一些建议可以帮助你减小 bundle 的体积</a></li></ul></li></ul></li><li>解析与执行 除了 JavaScript 下载需要耗时外，脚本的解析与执行也是会消耗时间的 <ul><li>JavaScript 的解析耗时</li><li>避免 Long Task</li><li>针对代码的优化</li></ul></li><li>缓存 <ul><li>发布与部署</li><li><a href="https://www.zhihu.com/question/20790576/answer/32602154" target="_blank" rel="noreferrer">大公司里怎样开发和部署前端代码？</a></li><li>将基础库代码打包合并</li><li>减少 webpack 编译不当带来的缓存失效 <ul><li>使用 Hash 来替代自增 ID</li><li>将 runtime chunk 单独拆分出来</li><li>使用 records</li></ul></li></ul></li></ul><h2 id="首屏加载" tabindex="-1">首屏加载 <a class="header-anchor" href="#首屏加载" aria-label="Permalink to &quot;首屏加载&quot;">​</a></h2><ul><li>Vue-Router路由懒加载（利用Webpack的代码切割）</li><li>使用CDN加速，将通用的库从vendor进行抽离</li><li>Nginx的gzip压缩</li><li>Vue异步组件 服务端渲染SSR</li><li>如果使用了一些UI库，采用按需加载</li><li>Webpack开启gzip压缩</li><li>如果首屏为登录页，可以做成多入口</li><li>Service Worker缓存文件处理</li><li>使用link标签的rel属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li></ul>`,62),o=[p];function r(t,c,i,y,F,D){return a(),l("div",null,o)}const A=s(e,[["render",r]]);export{h as __pageData,A as default};
