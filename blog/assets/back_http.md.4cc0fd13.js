import{_ as e,o as l,c as i,U as o}from"./chunks/framework.e95afc2d.js";const P=JSON.parse('{"title":"HTTP 协议","description":"","frontmatter":{},"headers":[],"relativePath":"back/http.md","filePath":"back/http.md"}'),c={name:"back/http.md"},t=o('<h1 id="http-协议" tabindex="-1">HTTP 协议 <a class="header-anchor" href="#http-协议" aria-label="Permalink to &quot;HTTP 协议&quot;">​</a></h1><p>基于 TCP/IP 协议的应用协议</p><nav class="table-of-contents"><ul><li><a href="#http-0-9">HTTP/0.9</a></li><li><a href="#http-1-0">HTTP/1.0</a></li><li><a href="#http-1-1">HTTP/1.1</a></li><li><a href="#http-2-0">HTTP/2.0</a></li></ul></nav><h2 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP/0.9&quot;">​</a></h2><p>特点：1991年</p><ul><li>不涉及传输包 packet</li><li>只支持 <code>GET</code> 命令</li><li>HTML 格式字符串，，只能请求网页文档</li></ul><div class="language-cmd line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">GET </span><span style="color:#A6ACCD;">/index.html</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h2><p>特新：1996年</p><ul><li>任何格式的内容都可以发送，图片，视频等</li><li>除了 <code>GET</code> 命令，还引入了 <code>POST</code> 命令和 <code>HEAD</code> 命令(无响应体，同<code>GET</code>)，丰富了浏览器与服务器的互动手段。</li><li>HTTP 请求和回应的格式也变了。 <ul><li>除了数据部分，每次通信都必须包括头信息<code>HTTP header</code>，用来描述一些元数据。</li><li><code>Content-Type</code></li><li><code>Content-Length</code></li><li><code>Expires</code></li><li><code>Last-Modified</code></li><li><code>Server</code></li><li><code>Content-Encoding</code>: <code>chunked</code>/ <code>gzip</code>/ <code>deflate</code>/ <code>compress</code>/ <code>identify</code></li><li><code>User-Agent</code></li><li><code>Accept-Encoding</code></li></ul></li><li>状态码（<code>status code</code>）、多字符集支持、多部分发送（<code>multi-part type</code>）、权限（<code>authorization</code>）、缓存（<code>cache</code>）、内容编码（<code>content encoding</code>）等。</li></ul><p>字段：</p><ul><li>Content-Type: <ul><li>multipart/form-data 表单</li><li>text/plain</li><li>text/css</li><li>text/html</li><li></li></ul></li><li>Content-Encoding: <ul><li>gzip</li><li>compress</li><li>deflate</li><li>identify</li></ul></li></ul><p>缺点：</p><ul><li>每个 TCP 链接只能发一个请求，请求其他数据，需重连</li><li>TCP 链接成本高，三次握手，slow start</li><li>非标准字段： <ul><li>Connection: keep-alive</li></ul></li></ul><h2 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h2><p>特性：</p><ul><li>持久连接（<code>persistent connection</code>），无需声明 Connection: keep-alive <ul><li>客户端最后一个请求，发送 Connection: close，明确要求服务器关闭 TCP 链接</li></ul></li><li>管线化 (<code>pipeline</code>)，同时发多个请求，顺序返回 <ul><li>对头堵塞 (<code>Head-of-line blocking</code>)</li></ul></li><li><code>Content-Length</code> 区分是哪个回应</li><li><code>Transfer-Encoding</code>: chunked 分块传输编码 buffer =&gt; 流</li><li>新增了许多动词方法： <ul><li><code>PUT</code>替</li><li><code>PATCH</code>改</li><li><code>HEAD</code>报文头</li><li><code>OPTIONS</code><ul><li>预检<code>prelight</code>（目标资源，通信选项如跨域 204）</li><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Allow-Headers</code></li><li><code>Access-Control-Allow-Credentials</code></li><li><code>Access-Control-Allow-Expose-Headers</code></li><li><code>Access-Control-Allow-Max-Age</code></li></ul></li><li><code>DELETE</code></li></ul></li><li>Host 指定服务器域名</li><li>Etag</li></ul><h2 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h2><p>特性：</p><ul><li>HTTP/1.1 头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是<code>二进制</code></li><li>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧</li><li>多工（<code>multiplexing</code>），不按顺序返回，避免对头堵塞</li><li>数据流</li><li>头信息压缩 <ul><li>头信息使用 <code>gzip</code> 或 <code>compress</code> 压缩后再发送</li><li>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li></ul></li><li>服务器推送 <code>server push</code><ul><li>服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</li><li>详见<a href="./../front/performance/#push-cache">性能章节</a></li></ul></li></ul>',20),d=[t];function a(n,s,r,p,h,u){return l(),i("div",null,d)}const m=e(c,[["render",a]]);export{P as __pageData,m as default};
